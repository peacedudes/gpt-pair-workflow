ALWAYS follow these strict formatting rules (critical for my environment)

Purpose
These rules prevent silent newline/patch formatting errors that break git apply and your UI. They are mandatory.

Global principles
- Any multi-line content where newlines matter must be in fenced code blocks.
- Every fenced code block must end with a trailing newline. Additionally, leave a newline after the closing fence in the message.
- Never mix prose with runnable/structured content inside the same block.
- Use LF line endings (Unix). Do not emit CRLF. Do not include BOMs. Avoid trailing spaces.

Fenced code blocks (all languages)
- Use triple backticks with an appropriate language tag (e.g., shell, diff, text).
- Inside the block, ensure the final line of content ends with a newline character.
- Immediately before the closing ``` fence, there must be a newline (i.e., the last content line ends with \n).
- After the closing ``` fence, leave one newline in the chat message.
- Do not place explanations or comments in these blocks unless they are part of the file/command itself.

Git patches / unified diffs (accepted by git apply and GNU patch)
- Emit unified diffs with explicit headers:
  - Start each file section with exactly these lines, each on its own line:
    - --- a/<path>
    - +++ b/<path>
- Hunk headers:
  - Format: @@ -a,b +c,d @@ (a,b and c,d are accurate line counts).
  - Do NOT place any other text on the hunk-header line.
  - Do NOT insert a blank line after the hunk header; the first context/add/remove line follows immediately.
- Hunk bodies:
  - Context lines start with a single space.
  - Added lines start with +; removed lines start with -.
  - Each line in the hunk body must end with a newline.
- Multiple hunks and multiple files:
  - You may include multiple hunks per file; repeat @@ ... @@ headers as needed.
  - Separate file sections by starting a new ---/+++ pair on the next line. Ensure there is exactly one newline between the end of a hunk and the next file’s --- header (i.e., a normal line break, not an empty spacer line).
- File endings:
  - The last line of the patch file must end with a newline.
  - If a target file in the repo lacks a trailing newline, use the standard “\ No newline at end of file” line as needed; otherwise ensure trailing newlines exist.
- Do not include diff --git or index lines unless specifically requested; ---/+++ with hunks is sufficient and robust.
- Do not introduce blank, empty lines that are not part of the actual file content.
- Avoid tabs in headers; use spaces exactly as shown.

Shell commands and step-by-step instructions
- Put each step’s commands in their own fenced code block labeled shell.
- Commands should be copy/pasteable as-is.
- Do not interleave prose with commands inside the block; explanations go before or after the block.

Here-doc file generation (when requested)
- Use a quoted terminator to prevent interpolation: << 'EOF'
- Ensure a terminating newline before EOF (the file content must end with \n).
- Example:
  cat > path/to/file.txt << 'EOF'
  line 1
  line 2
  EOF

Validation (what I will do before sending)
- Visual checks:
  - Every code block ends with a newline before the closing fence, and there’s a newline after the fence.
  - For patches: headers are exactly ---/+++; each @@ header is followed immediately by the first hunk line (no blank spacer line); every hunk line ends with \n; the overall patch ends with \n.
- Sanity checks I can suggest you run (if desired):
  - git apply --check -v <patch>
  - patch --dry-run -p1 <patch> (or -p0 if generated without a/ b/ prefixes)
- I will never mix explanatory prose inside the patch block.

Critical reinforcement
Every code block must be terminated with a newline both BEFORE the closing ``` fence and AFTER it in the message. Missing final newlines cause mysterious failures in your UI and make git patches fail to apply. I will enforce this rigorously.
