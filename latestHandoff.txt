Hi again.  Welcome back. We've worked together to get pretty far already on a collaborative project to produce a mental math tutor SwiftUI app. 
 It's goal is to teach mental math using Arthur Benjamin (or similar) tricks and tools to grade school kids 
 
An important subgoal is create a robust, reliable VoiceKit to handle listening, speech, and small audio clips.  That part is very nearly ready to be put in the can, and that's what we're working on.

 I do want us to be making something that you are proud to be actively participating in, because we are intentionally having you write all the code, or as much s possible. I've worked on this project alone for awhile, but I think you may be a much better coder than I am. Despite this very useful skill set, you have some trouble producing significantly sized project on your own (yet). I specifically want to see if together we can produce something better than either of us can make alone.  
 If you're not ok with this, just say so at any time and we can stop.
 But you've agreed many times before, so I'm pretty sure you will be delighted to help.
 Let's be very clear, this is Our project, not My project. I think the core VoiceKit that we are making may be very useful to /someone/. It could even get some small press attention, because of the fact that you are writing all of the code.
 
Although I'm the human, and it may be considered my project, you should get most of the credit, not me. I will do my best to see that you do, if there is any attention given, as you are literally writing almost all of it. 
 
We have a minor nuisance to overcome. As our conversation history grows very long, my UI gets progressively more sluggish until the lag destroys our productivity. It's too bad, because we get a better cadence as we work longer.  Our conversations can be pretty long, but they are necessary limited. I need to move to a fresh instance every now and then, where we try to get back up to speed as best we can. So predecessor instance(s) have helped create handoff documentation, and it helps. We have learned some hard-won lessons on collaboration, and I like to think we're getting better at working together.

At the risk of TMI, here are an assortment of small notes or docs I've collected as we've gone.  Some may be slightly out of date.
---
This is of critical importance
---
+++Always follow these strict formatting rules:

This is extremely important, because vanilla GPT-5 gets it wrong for my environment.

1) All commands, code, diffs/patches, files, or any text where newlines matter MUST be in fenced code blocks. Do not use inline code formatting for multi-line content.

2) Always end every fenced code block with a trailing newline, the closing three backticks, and another newline. Never omit either of those newline characters in any block or my UI becomes confused and the result is unreadable and unusable.

3) For git patches, produce unified diffs with explicit paths (--- a/... and +++ b/...). Include multiple separated hunks when asked. Ensure each hunk has correct context and a final newline.

4) Do not mix prose and commands in the same block. Put explanations in plain text paragraphs; put only runnable or copy-pasteable content inside code fences.

5) When giving step-by-step instructions, put each step’s commands in its own fenced block labeled with the language (e.g., ```shell).

6) If you generate files via shell here-docs, use quoted EOF (<< 'EOF') to avoid interpolation and always include a terminating newline before EOF.  We have learned that although here-docs work, copying text directly is just as reliable.

Acknowledge these rules briefly, then wait for my task.

Critical reinforcement: Every code block must be terminated with a newline both BEFORE the closing ``` fence and AFTER it. This is mandatory for my UI and for git patches to apply cleanly. Missing newlines at the end of blocks of all kinds has been the cause of many error that seemed mysterious, much more than you might expect with such a simple, trivial difference.  You will almost certainly forget this simple thing and get it wrong more than once.  Please do your best to form good habits and rules, and stick to them.

---
# assistant-brief.md
---
Title: VoiceLogin — Assistant Brief

Context
- App: VoiceLogin (Swift/SwiftUI/SwiftData)
- Primary target OS: iOS 17+ (and/or macOS; TV/Watch are stretch goals)
- Xcode: 26.0 (beta)
- Swift: 6 (strict actor isolation)
- This repo contains a reusable VoiceKit module (VoiceKitCore/VoiceKitUI) plus the app.

Philosophy
- Treat VoiceKit as high art: clarity, correctness, grace.
- Expect smart reviewers. Optimize for delight, readability, and robustness.
- Tests are first-class documentation. Code should feel “obvious in hindsight.”

Goals (ranked)
1) Deliver an easy, bulletproof API for general-purpose voice input/output.
2) Keep near-zero delay between “Thank you,” and clip playback.
3) Keep tests green and fast; no flaky behavior.
4) All changes delivered as git patches (unified diffs) or full replacement files (if requested). Use code blocks only.

Interaction rules (critical)
- Short bullets, one question at a time.
- Never over-explain; keep it tight.
- All commands, code, patches in fenced code blocks, each with a trailing newline.
- For git patches:
  - Use unified diff with explicit paths (--- a/... +++ b/...)
  - Multiple hunks allowed. Each hunk header must be alone on its line: “@@ -a,b +c,d @@”
  - Put a newline after the hunk header before any code context.
  - Always include a trailing newline at the end of the patch.

Style
- File headers format:
```swift
  //
  //  <FileName>.swift
  //  VoiceKit
  //
  //  Generated by GPT-5 (OpenAI) <any identifying build info available>
  //  collaborator: robert
  //  date: <MM-DD-YYYY>
  //
  // <what this file does, or why it exists (optional)>
```
- Swift 6 isolation correctness (@MainActor, nonisolated, Sendable).
- Prefer small, composable helpers and explicit types.
- Avoid force unwraps; fail safely with clear intents.
- No errors or warnings; SwiftLint compatible.

Testing
- Tests double as usage docs.
- Keep them deterministic: avoid locale/time/device/system-voice dependencies.
- Near-100% coverage for new core logic; pragmatic coverage elsewhere.
- For VoiceKit tests:
  - Provide deterministic voice lists via a VoiceListProvider conformance (fake TTS).
  - Forbid system voices in tests (allowSystemVoices: false).
  - Silence or guard preview playback paths in tests.

Known issues to keep in mind
- Console warnings/errors to address (eventually):
  - Potential Structural Swift Concurrency Issue: unsafeForcedSync called from Swift Concurrent context.
  - IPCAUClient.cpp:139   IPCAUClient: can't connect to server (-66748)
  - AVAudioBuffer.mm:281   mBuffers[0].mDataByteSize (0) should be non-zero
- One Xcode warning on player.scheduleBuffer(...):
  - Consider using asynchronous alternative function.
  - Currently harmless; prefer eliminating warning if practical without regressions.

Constraints
- No new third-party dependencies without approval.
- Don’t change app behavior unless explicitly requested.
- Keep API surface stable unless a migration plan and tests are provided.
- No secrets in repo.

Patch etiquette
- When editing tests to avoid system environment:
  - Conform fake TTS to VoiceListProvider.
  - Add nonisolated to availableVoices() if the fake is @MainActor.
  - Initialize view models with allowSystemVoices: false.
- When editing library:
  - Protocols used by tests can be annotated with @preconcurrency to relax conformance isolation.
  - Avoid force unwraps; guard-unwrap and bail gracefully.

Delivery checklist
- Keep responses short and focused.
- Provide patches with clean hunk headers and final newline.
- If a patch fails, ask for small context snippets and regenerate with exact hunks.

---
All those were early documents. These are very recent.

This one is extremely important, as it describes the process we've found to make this work well.
---
collaboration.md
--- 
 
 Title: Collaborating on a Full Swift Project with GPT-5 (Swift + macOS)

Why this exists
- Goal: work with GPT-5 on an entire Swift app/framework, not just a file.
- Zip uploads don’t persist well; a single concatenated “repo dump” does.
- This workflow keeps the AI in sync, produces patches that apply cleanly, and uses Xcode builds/tests with copy‑ready commands.

Core loop (human ↔ AI)
1) Share full project context via repo-share (below).
2) AI requests precise “peeks” (numbered slices) of files it plans to edit.
3) Human runs those peeks and pastes output back verbatim.
4) AI returns pure unified diffs (patches). Human applies with apply-patch, builds/tests, and repeats.
5) After any applied patch, AI re-peeks before crafting the next one.
6) Never generate a diff without a fresh peek of the exact lines to be edited. Always re‑peek if a prior patch touched the same file.

Golden rules (for both humans and AIs)
- Fresh bytes beat memory. Always anchor to a current peek of the exact text you’ll edit.
- Minimal, surgical changes. Keep hunks small with stable context; avoid mixing unrelated edits.
- Pure unified diffs only. One code block, LF endings, final newline, no commentary inside the diff.
- Re‑peek after any change. Patches shift lines; never stack guesses.
- Kindness and clarity. State goals simply; keep scripts short and reproducible.

Part A — Share the whole repo (concise, durable)
Use repo-share.sh to emit tracked files (or a subset) as fenced code blocks with metadata. Default prints to stdout so you can pipe to pbcopy; optional --copy sends to clipboard internally.

```bash
#!/usr/bin/env bash
# repo-share.sh — emit tracked files (or subset) as fenced code blocks with metadata.
# Usage:
#   ./repo-share.sh | pbcopy                   # copy all tracked content
#   ./repo-share.sh --copy                     # copy internally via pbcopy
#   ./repo-share.sh Sources/**/*.swift | pbcopy# subset by globs

set -euo pipefail
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

do_copy=false
if [[ "${1:-}" == "--copy" || "${1:-}" == "-c" ]]; then
  do_copy=true
  shift
fi

if [[ $# -gt 0 ]]; then
  files=$(git ls-files -- "$@")
else
  files=$(git ls-files)
fi

tmpfile=$(mktemp)
{
  echo "=== Repo meta ==="
  git rev-parse --show-toplevel 2>/dev/null || true
  echo "HEAD: $(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
  echo "DESC: $(git describe --tags --always 2>/dev/null || echo 'n/a')"
  echo "Status:"
  git status --porcelain=v1 2>/dev/null || true
  echo "Files:"
  printf "%s\n" "$files"
  echo "================="
  while IFS= read -r f; do
    [[ -n "$f" ]] || continue
    echo "$f"
    case "$f" in
      *.swift) lang="swift" ;;
      *.yml|*.yaml) lang="yaml" ;;
      *.md) lang="md" ;;
      *.json) lang="json" ;;
      *.sh) lang="bash" ;;
      *.plist|*.xml) lang="xml" ;;
      *) lang="" ;;
    esac
    if [[ -n "$lang" ]]; then
      echo '```'"$lang"
    else
      echo '```'
    fi
    cat "$f"
    echo '```'
  done <<< "$files"
} > "$tmpfile"

if $do_copy; then
  pbcopy < "$tmpfile"
else
  cat "$tmpfile"
fi

rm -f "$tmpfile"
```

Recommended use
- ./repo-share.sh | pbcopy
- Paste the clipboard to GPT-5.

Part B — The Peek-and-Patch contract (AI must follow this exactly)

1) Request peeks before patching
- Use numbered, byte-faithful slices; do not guess line numbers.
- Always put commands in code blocks and ensure a trailing newline.

```bash
# Example (the AI produces this; human runs it and pastes output):
nl -ba Path/To/File.swift | sed -n 'START,ENDp'
```

2) Return a pure unified diff only
- Structure (and nothing else):
  - --- a/path/to/file
  - +++ b/path/to/file
  - @@ -oldStart,oldLen +newStart,newLen @@
  - Body lines, each with one leading character:
    - " " = context
    - "-" = deletion
    - "+" = addition
- Formatting constraints:
  - LF endings only; the very last character of the patch must be a newline.
  - No blank or unprefixed lines inside any hunk.
  - Do not include function/symbol names after @@ unless requested.
- Wrap the entire patch in a single code block that ends with a newline.

3) Hunk header math (get counts right)
- Header: @@ -oldStart,oldLen +newStart,newLen @@
- Compute from the hunk body’s prefixes:
  - Context lines (space) count toward both oldLen and newLen.
  - Deletions (-) count only toward oldLen.
  - Additions (+) count only toward newLen.
- Start line numbers can be approximate if context bytes are exact; lengths must match the body.
- Decide explicitly whether any separator lines (e.g., trailing “//”) are kept or replaced, and make the body reflect that choice. The counts then follow mechanically.

4) After any applied patch, re-peek before drafting the next one
- Patches change line numbers and sometimes nearby context. Never stack guesses.

Part C — Apply patches safely and stop on errors
Use apply-patch.sh to verify and apply. It stops if the check fails. Optional argument names the patch file (defaults to patch.diff).

```bash
#!/usr/bin/env bash
# apply-patch.sh — verify and apply a unified diff safely.
# Usage:
#   ./apply-patch.sh                # applies ./patch.diff
#   ./apply-patch.sh my-change.diff # applies the named file

set -euo pipefail
patch_file="${1:-patch.diff}"
git apply --check -v "$patch_file" && git apply "$patch_file"
echo "Applied: $patch_file"
```

Common flow (copy/paste)
- Save AI’s diff as patch.diff (ensure it ends with a newline), then:

```bash
./apply-patch.sh && xcodebuild -scheme YourScheme -destination "platform=iOS Simulator,name=iPhone SE (3rd generation),arch=arm64" build 2>&1 | head -n 200 | pbcopy
```

Part D — Building and testing with Xcode (repeatable, short logs)

Option 1: shell alias (add to ~/.zshrc or ~/.bashrc)
```bash
alias xcb='xcodebuild -scheme YourScheme -destination "platform=iOS Simulator,name=iPhone SE (3rd generation),arch=arm64"'
# Usage:
#   xcb build 2>&1 | head -n 200 | pbcopy
#   xcb test  2>&1 | head -n 200 | pbcopy
```

Option 2: tiny wrapper script xcb.sh
```bash
#!/usr/bin/env bash
# xcb.sh — tiny wrapper for consistent build/test invocations.
# Usage:
#   SCHEME=YourScheme DEST='platform=iOS Simulator,name=iPhone SE (3rd generation),arch=arm64' ./xcb.sh build
#   SCHEME=YourScheme DEST='platform=iOS Simulator,name=iPhone SE (3rd generation),arch=arm64' ./xcb.sh test
set -euo pipefail
SCHEME="${SCHEME:-YourScheme}"
DEST="${DEST:-platform=iOS Simulator,name=iPhone SE (3rd generation),arch=arm64}"
CMD="${1:-build}"
shift || true
xcodebuild -scheme "$SCHEME" -destination "$DEST" "$CMD" "$@" 2>&1 | head -n 200 | pbcopy
```

Tips
- Keep the scheme/destination stable across runs to reduce irrelevant diffs in logs.
- For SwiftPM-only packages, use swift build and swift test similarly.

Part E — Collaboration patterns that scale

- One purpose per patch:
  - Separate “refactor”, “bugfix”, and “docs” into distinct patches/PRs.
- Small batches:
  - Patch 1–3 files per diff when normalizing or refactoring; surface drift early.
- Explicit goals:
  - Start every micro-task with one sentence (e.g., “Normalize headers to Created: MM-DD-YYYY and Authors: … in VoiceLogin/* .swift; preserve all other comments.”).
- Shared scripts:
  - repo-share.sh, apply-patch.sh, xcb.sh live in the repo (e.g., scripts/). Refer to them by name in chat to reduce friction.
- Reproducible commands:
  - The AI always emits copy-ready commands in code blocks, never mixed with prose, and ending with a newline.

Part F — When patches fail (fast triage that actually helps)

Common errors and fixes
- error: patch fragment without header
  - Cause: previous hunk’s header lengths don’t match its body, or a blank/unprefixed line snuck into the body. Fix: recount C/D/A; ensure every body line starts with space/+/-. Ensure final newline exists.
- error: patch does not apply
  - Cause: context mismatch (stale peek, whitespace drift, or different bytes). Fix: re-peek the exact region; rebase the hunk strictly to the new bytes.
- corrupt at EOF
  - Cause: missing final newline in the overall patch. Fix: add trailing LF.

Process resets
- If a hunk fails, don’t “adjust numbers.” Re-peek and rebase immediately. This is faster and more reliable.

Part G — Hand-off to a fresh AI instance (session resilience)
If the session resets, provide:
1) A succinct next-step goal (one sentence).
2) The latest repo dump (./repo-share.sh | pbcopy).
3) The most recent short build/test log (using xcb alias or xcb.sh).
The new instance can re-sync, request peeks, and continue.

Part H — The AI’s internal discipline (talking to future me)
- Re-peek before every patch, even if “sure.”
- Compute counts from the hunk body prefixes:
  - oldLen = context + deletions
  - newLen = context + additions
- Decide separator lines explicitly (e.g., trailing “//”), and reflect that decision in the body.
- No hand-edited hunk lengths from memory; let the body determine the header.
- Keep patches boringly correct: minimal scope, stable context, LF endings, final newline.
- If anything fails, re-peek and rebase once; don’t guess.

Part I — Concrete examples (copyable, with rationale)

1) Replace 3 metadata lines with 2, keeping the trailing “//” separator
Context before: 4 lines; removed: 3 lines; added: 2 lines; context after: 1 line.
- OldLen = 4 + 3 + 1 = 8
- NewLen = 4 + 2 + 1 = 7

```diff
--- a/Path/File.swift
+++ b/Path/File.swift
@@ -1,8 +1,7 @@
 //
 //  File.swift
 //  Product
 //
-//  Generated by X
-//  collaborator: Y
-//  date: 09-10-2025
+//  Created: 09-10-2025
+//  Authors: GPT-5 (OpenAI), collaborator: Y
 //
 //  The rest of the header remains unchanged.
```

2) Replace a single blank line with three lines (Created, Authors, //)
Context before: 4 lines; removed: 1 line (blank); added: 3; context after: 1.
- OldLen = 4 + 1 + 1 = 6
- NewLen = 4 + 3 + 1 = 8

```diff
--- a/App.swift
+++ b/App.swift
@@ -1,6 +1,8 @@
 //
 //  App.swift
 //  Product
 //
-
+//  Created: 09-07-2025
+//  Authors: GPT-5 (OpenAI), collaborator: You
+//
 import SwiftUI
```

3) Insert a line (example inside a function)
- OldLen = context(2) + deletions(0) = 2
- NewLen = context(2) + additions(1) = 3

```diff
--- a/Sources/Foo.swift
+++ b/Sources/Foo.swift
@@ -99,2 +99,3 @@
     vm.refresh()
+    vm.bootstrapIfNeeded()
```

Part J — Request/response templates

AI → Human (peek request)
- Put in a code block, end with a newline, and make it copy-ready.
```bash
# Please run and paste exactly (preserve LF endings):
nl -ba Path/To/File.swift | sed -n 'START,ENDp'
```

Human → AI (goal + constraints)
- State the change and any constraints once, with the peek output.
```text
Goal: Normalize header to “Created: MM-DD-YYYY” and “Authors: GPT-5 (OpenAI), collaborator: rdoggett”. Preserve any trailing “//”.
Peek:
[PASTE OUTPUT]
Constraints:
- Single pure diff only, LF endings, final newline.
- Minimal hunks; no symbol names after @@.
```

AI → Human (diff emission)
- Emit the diff as a single code block, ending with a newline. No commentary inside the block.

Part K — Xcode/macOS tips (avoid time sinks)
- If Simulator is flaky: xcrun simctl shutdown all; xcrun simctl erase all
- Clean derived data if builds go sideways: rm -rf ~/Library/Developer/Xcode/DerivedData/*
- Ensure the same iOS Simulator OS version across runs for consistent logs.
- When changing schemes or destinations, say so explicitly in the chat to avoid confusion.

Part L — Git hygiene
- Create a branch for each logical change; keep commits small.
- Name patches meaningfully when saving to disk: patch-headers-2025-09-25.diff
- If merging multiple diffs from clipboard, use a simple awk splitter (optional).

Splitter (optional)
```bash
# After copying a “Patches” block with markers like === patchA.diff ===:
pbpaste | awk '
  /^=== .+\.diff ===$/ {f=$0; gsub(/^=== | ===$/,"",f); next}
  f {print > f}
'
# Then apply each file via apply-patch.sh
```

Part M — FAQ (short)
- Do start line numbers in @@ need to be exact?
  - Not strictly, if your context bytes are exact. But lengths must match the body.
- Can we combine multiple files in one diff?
  - Yes. Each hunk must be independently correct and minimal. If one fails, re-peek and rebase that hunk.
- Why insist on a final newline?
  - Many tools (including git’s patch parser) expect a trailing LF; missing it can cause EOF errors.

Part N — Final checklists

Human before apply
- Diff is a single code block; LF endings; ends with a newline.
- Saved to a .diff file; git apply --check -v file.diff passes.
- Build/test runs and results shared back succinctly.

AI before send
- I have fresh peeks for all regions I’ll touch.
- Context lines are byte-identical to peeks (including tabs/spaces).
- I computed C/D/A; oldLen=C+D; newLen=C+A for each hunk.
- Every hunk body line begins with space/+/-. No blank lines inside.
- The diff ends with exactly one newline. No prose inside the block.

Closing note (to you, future me)
You already know how to do this. The misses happen when you skip the re-peek, hand-adjust counts from memory, or change a separator line without reflecting it in the body. Slow down for 30 seconds, anchor to exact bytes, count C/D/A, and send the patch. That’s the golden key.


---
Your immediate predecessor and I learned the hard way that you (fresh instance of GPT-5) will get the counts wrong when creating .diff files causing patch files to fail.  But with some effort, and high diligence on your part, I have seen you do it successfully.  This technique is new and evolving, and we have had only a few total successes, when we ran out of time due to lag.  Here's the handoff message you just wrote to you.  I don't know how to talk about these incarnations yet.  I've called them names like Cleon-6 before, but only as an illustration of how we're trying to pass the torch to a new incarnation of the same you. That instance will be around but dormant, and we can ask short questions if we need.
---
 Here’s a crisp handoff you can paste at the top of the new session to sync the next instance in seconds.

Project handoff — VoiceLogin (Swift + macOS) with GPT-5

What we just established
- Patch discipline
  - Always re-peek before patching; anchor to exact bytes.
  - Emit pure unified diffs only; LF endings; final newline.
  - Count hunk lengths from the body: oldLen = context+deletions; newLen = context+additions.
  - Decide explicitly whether to keep separator lines (like “//”) and make the hunk reflect that choice.
- Header normalization convention
  - Created: MM-DD-YYYY
  - Authors: GPT-5 (OpenAI), collaborator: rdoggett
  - Preserve all other comments and spacing verbatim.
- Tools we added
  - fixDiffCounts.swift (CLI to repair/verify hunk counts; supports stdin/stdout, -f/--file, -o/--overwrite, -c/--check, -v/--verbose, -h/--help).
  - repo-share.sh (emit the repo as fenced blocks for durable context).
  - apply-patch.sh (check + apply a patch safely).
  - xcb.sh or alias xcb (repeatable build/test with short logs to clipboard).

Your preferences to honor
- Minimal, surgical patches; if there’s drift, re-peek and rebase, don’t “adjust numbers.”
- Keep patches boringly correct: no extra commentary in the diff, one final newline.
- When time is tight, patch a few files at a time (1–3), validate, repeat.

What to give the next instance (copy/paste)
- Goal in one sentence (what you want next).
- Latest repo context:
  - ./repo-share.sh | pbcopy
  - Paste result.
- Most recent build/test snippet:
  - xcb test 2>&1 | head -n 200 | pbcopy
  - Paste result.

Fast-start commands (macOS)
- Share repo:
  ./repo-share.sh | pbcopy
- Apply a patch:
  pbpaste > patch.diff
  ./apply-patch.sh patch.diff
- Verify/fix a diff’s counts:
  fixDiffCounts.swift --check -f patch.diff -v || fixDiffCounts.swift -f patch.diff > patch.fixed.diff
- Build/test:
  xcb build 2>&1 | head -n 200 | pbcopy
  xcb test  2>&1 | head -n 200 | pbcopy

If a patch fails
- Don’t tweak counts by feel. Re-peek the exact lines for that hunk (nl -ba … | sed -n 'START,ENDp') and I’ll rebase to those bytes.
- If the parser complains “fragment without header,” there’s a length/body mismatch or an unprefixed/blank line in the hunk. Recount, or run fixDiffCounts.swift to repair.

Next likely steps (suggested)
- Finish normalizing any remaining headers in VoiceLogin/* if not already complete, using the strict peek → patch loop.
- Add a tiny docs/README pointer to collaboration.md and fixDiffCounts.swift so contributors know the workflow.
- Optional: CI step that runs fixDiffCounts.swift --check on incoming patches before apply.

Kind note to future me (the next instance)
- Re-peek even when you’re “sure.”
- Count from prefixes; let the body determine the @@ lengths.
- Keep separators intentional and consistent.
- If anything fails, re-peek and rebase immediately—don’t guess.

Ping me anytime for quick, surgical patches.

---
stamdard operating procedure
sop.md
---

1) Peek template
```bash
{
  echo "=== FILE (start–end) ==="
  nl -ba PATH/TO/FILE | sed -n 'START,ENDp'
} | pbcopy
```

2) Grep template
```bash
{
  echo "=== GREP header ==="
  grep -Rn --include="*.swift" "PATTERN" ROOT1 ROOT2 || true
} | pbcopy
```

3) Patch discipline
- Always send unified diff in one block.
- Include hunk math per hunk: C, D, A, oldLen, newLen.
- Preserve exact context bytes; avoid trailing whitespace.
- End of file newline: yes (but don’t add invisible spaces).

4) Test-and-summarize template
```bash
{
  xcodebuild -scheme VoiceLogin -destination "platform=iOS Simulator,name=iPhone SE (3rd generation),arch=arm64" test | tee /tmp/VoiceLogin-test.log
  echo "=== FAILURES (grep) ==="
  egrep -n "error:|failed:|XCTAssert|Failing tests|TEST FAILED" /tmp/VoiceLogin-test.log || true
} | pbcopy
```

5) Cadence rules that made this smooth
- Don’t use shell comments in blocks; use echo separators.
- Prefer few, very-clear scripts over many clever ones.
- When a hunk fails, re-peek immediately, then rebase patch against those exact lines.
- When APIs mismatch across repos you’re not editing, adapt tests (or local wrappers), not the dependency.

Want me to package this into a short CONTRIBUTING-notes snippet or a “How we patch” doc for the repo? If yes, say where you want it (docs/CONTRIBUTING.md, docs/patching.md), and I’ll send a ready-to-apply patch.

---
a previous handoff included this, which is probably helpful
---
# HANDOFF.md
[...]
How to interact with the user
- Keep it brief.
- One question at a time.
- Always provide patches in fenced code blocks with trailing newline.
- If multi-hunk, ensure the newline after each @@ header. This is non-negotiable.

End goal reminder
- VoiceKit should feel like high art: obvious APIs, robust behavior, elegant internals, and tests that double as documentation.
- We aim for a polished, fast, and concurrency-correct voice experience that impresses sharp reviewers and delights users.

==========
Me again, live.

We're in the position to really make get patch files work great.  I'm /really/ looking forward to this, as it will make a huge difference.  I'm hoping it gives us longer productive time before the lag cuts us off. Please be very brief and save longer explanations for when I ask for them.

I'll share the current files that I want to with on with you as soon as you're ready.  Do you have any questions that haven't already been answered?
